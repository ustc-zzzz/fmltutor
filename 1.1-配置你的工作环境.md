## 写在前面

基础部分讲述的内容，是几乎所有Mod都会频繁使用的、较为容易实现的特性。

建议读者在阅读完绪论后，对于初级部分的每一部分都加以阅读。

## 配置工作环境

解压在上一部分，也就是绪论中提到的下载到的文件，进入该目录，也就是工作环境的根目录。

如果你使用的是Linux或者Mac OS X，在该目录下运行命令：

```
./gradlew setupDecompWorkspace
```

如果你使用的是Microsoft Windows，则运行：

```
gradlew.bat setupDecompWorkspace
```

后面的所有类似命令、都将描述的是在Linux或者Mac OS X的运行方式，如果是Microsoft Windows用户请将后面的所有命令中的`./gradlew`替换成`gradlew.bat`，教程不再赘述。

可以通过添加参数的方式设置代理，`<host>`表示代理服务器的地址，`<port>`表示开放代理的端口。

使用socks代理的方式：

```
./gradlew setupDecompWorkspace -DsocksProxyHost=<host> -DsocksProxyPort=<port>
```

针对https资源使用http代理的方式：

```
./gradlew setupDecompWorkspace -Dhttps.proxyHost=<host> -Dhttps.proxyPort=<port>
```

针对http资源使用http代理的方式：

```
./gradlew setupDecompWorkspace -Dhttp.proxyHost=<host> -Dhttp.proxyPort=<port>
```

因为资源大多在国外，所以可能要等待一段漫长的时间。建议在网络状况好的地方运行此命令，以配置开发环境，并获取反编译过的Minecraft源代码。如果有条件，建议使用国外的代理。

在此我们提供了一个免费Shadowsocks代理服务器来帮助您构建:

> **server:** forge-build-srar-telecom.ustc-zzzz.net  
> **server\_port:** 65099  
> **password:** 9c4d5a9a6d97  
> **method:** rc4-md5  

Shadowsocks客户端默认监听`127.0.0.1:1080`作为代理服务来运行, 当您配置完Shadowsocks后您可以执行以下命令来使用代理进行构建:

```
./gradlew setupDecompWorkspace -Dhttps.proxyHost=127.0.0.1 -Dhttp.proxyHost=127.0.0.1 -Dhttps.proxyPort=1080 -Dhttp.proxyPort=1080
```

> 推荐使用的ShadowsocksR客户端：<https://github.com/breakwa11/shadowsocks-rss>
>
> 需要注意的是本代理__仅提供给您构建加速服务__所以在服务端处我们屏蔽了一些域名与全部IPv4地址
>
> * .google.com
> * .youtube.com
> * .dropbox.com
> * .twitter.com
> * .facebook.com
> * .instagram.com
> * ...以及其他热门网站域名
>

由于获取反编译的Minecraft源代码的过程是在自己的计算机上进行的，所以说有时可能出现内存不足的情况。如果运行一次后出现的错误中有`Java Heap Space`的字样，那很可能是因为默认情况下分配的内存不足。这时你可以添加下面的参数手动指定JVM的初始内存，同时禁用[Gradle Daemon](https://docs.gradle.org/current/userguide/gradle_daemon.html)以减少不必要的内存消耗（当然，减少计算机上的其他不必要进程以提高内存可用空间也很重要）。经过作者测试，1.4G的内存足够反编译Minecraft了：

```
./gradlew setupDecompWorkspace -Dorg.gradle.jvmargs=-Xms1440m --no-daemon
```

最后如果出现`BUILD SUCCESSFUL`字样，就代表你第一步的配置成功了，以下所有需要用到`./gradlew`的运行结果都以`BUILD SUCCESSFUL`字样为成功的标志，如果出现了`BUILD FAILED`字样，那么代表尚未成功，可以重新运行相同的命令尝试，如果还是不可以，可以尝试使用上面提到的使用代理的模式，并尝试手动指定JVM的初始内存。

如果你使用Eclipse作为你的IDE，请在上面的命令运行完成后运行命令：

```
./gradlew eclipse
```

如果你使用IntelliJIDEA（IDEA大法好→_→）的话：

```
./gradlew idea
```

使用代理的方式同上。

然后打开IDE，将工程目录切换到这个目录，如果配置成功，IDE会注意到这个目录存在一个工程，并自动找到刚刚配置的这个Mod工程的源代码和资源文件的位置。

默认配置中，Mod工程的源代码在目录`src/main/java`下，而Mod工程的资源文件（如图片、模型等）在目录`src/main/resources`下。读者应该会发现在Mod源代码中有一个`com.example.examplemod`的包，那个是测试用的，删掉就可以了。

## 运行、构建和发布Mod的方法

如果你想构建并发布你的Mod，运行下面的命令：

```
./gradlew build
```

这样根目录下的`build/libs/`里会有一个jar包，那便是你构建完成的Mod文件。

如果想要运行客户端，运行：

```
./gradlew runClient
```

如果想要运行服务端，运行：

```
./gradlew runServer
```

客户端和服务端的运行文件将在根目录的`eclipse`文件夹中。

上面三个命令在非特殊情况下，强烈建议添加`--offline`参数，阻止与外界网络的连接，即对国外的资源的访问，以提高速度。

当然，你也可以在你的IDE中运行、或者调试你的Mod。

对于Eclipse而言，Forge在针对IDE配置的时候，已经添加了相关的运行选项。不过对于IntelliJIDEA而言，你可能需要多运行一条命令：

```
./gradlew genIntellijRuns
```

然后你的IntelliJIDEA中就应该有运行选项了。

## Mod的唯一标识符

每个Mod都会有一串唯一标识符用于与其他Mod相区分，这个标识符我们通常也称为modid。

**modid请全部使用小写字母，并且不要使用除英文字母和下划线外的其他符号**。实际上，Forge从Minecraft 1.11对应的某个Forge版本开始就不支持含有大写字母的modid了（同时modid的长度不得超过64个字符，不过应该没人会起那么长的modid）。当然，你可以使用小写加下划线的`snake_case`形式，事实上我们也推荐使用这一形式。

modid一旦决定，就不能轻易改动，因为其他Mod很可能根据这一唯一标识符来识别你的Mod，如果名称发生更改则可能带来意料之外的影响，所以考虑modid时一定要慎重。

## Forge是如何管理工程的

很明显，Mod的管理、构建都十分复杂，所以Forge使用了一个被称为[Gradle](https://gradle.org/)的工具，还通过编写插件的方式对其进行了[修改](https://github.com/MinecraftForge/ForgeGradle)。Gradle本身是一个比较强大的工程构建工具，它本身集成了很多的编译、构建选项，却又十分简单（相对[Maven](https://maven.apache.org/)来说）。

在你的根目录下应该有一个文件名为`bulid.gradle`的文件（为了节省篇幅，这里删掉了所有的注释）：

**`build.gradle:`**

```
buildscript {
    repositories {
        jcenter()
        maven {
            name = "forge"
            url = "http://files.minecraftforge.net/maven"
        }
    }
    dependencies {
        classpath 'net.minecraftforge.gradle:ForgeGradle:2.1-SNAPSHOT'
    }
}
apply plugin: 'net.minecraftforge.gradle.forge'

version = "1.0"
group= "com.yourname.modid"
archivesBaseName = "modid"

minecraft {
	version = "1.8.9-11.15.1.1722"
	runDir = "run"
	
	mappings = "snapshot_20141130"
}

dependencies {

}

processResources
{
	inputs.property "version", project.version
	inputs.property "mcversion", project.minecraft.version

	from(sourceSets.main.resources.srcDirs) {
	    include 'mcmod.info'
	            
	    expand 'version':project.version, 'mcversion':project.minecraft.version
	}
	    
	from(sourceSets.main.resources.srcDirs) {
	    exclude 'mcmod.info'
	}
}
```

这里，我们找到其中的三行：

**`build.gradle（部分）:`**

```
version = "1.0"
group= "com.yourname.modid"
archivesBaseName = "modid"
```

并更改掉它：

**`build.gradle（部分）:`**

```
version = "1.0.0"
group = "com.github.ustc_zzzz"
archivesBaseName = "fmltutor"
```

`version`表示该Mod的版本。关于版本的设置，可以参照一个GitHub推荐的，被称为[语义化版本](http://semver.org/lang/zh-CN/)的标准（[英文原版](http://semver.org/)），按照这个标准，作为第一个正式版本，显然应该是1.0.0。

`group`表示组id，建议使用Java包命名规范，比如如果你这个项目所在网站为`www.example.com`，那么包名建议为：

```
com.example.<your_username>.<your_project_name>
```

比如本教程的所有代码都在这个包下：

```
com.github.ustc_zzzz.fmltutor
```

当然如果没有网站，也可以直接使用用户名：

```
<your_username>.<your_project_name>
```

比如对于本教程的代码，可以这样命名：

```
ustc_zzzz.fmltutor
```

当然，也有直接以Mod名称作为包命名的，等等。

总而言之，包的命名以不冲突为前提。

`archivesBaseName`表示生成的Mod包使用的名称，Mod包使用的文件名是“名称+横线+版本号.jar”，这里就是`fmltutor-1.0.jar`。

Gradle本身有一个详细的[User Guide](https://docs.gradle.org/current/userguide/userguide.html)，如果读者对进一步的配置感兴趣，可以仔细阅读。

对于Mod进一步的配置，我们会在下一部分中提及。
